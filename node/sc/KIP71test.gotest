func TestKIP71policy(t *testing.T) {
	tempDir, err := ioutil.TempDir(os.TempDir(), "sc")
	assert.NoError(t, err)
	defer func() {
		if err := os.RemoveAll(tempDir); err != nil {
			t.Fatalf("fail to delete file %v", err)
		}
	}()

	wg := sync.WaitGroup{}
	wg.Add(2)

	// Config Bridge Account Manager
	config := &SCConfig{}
	config.DataDir = tempDir
	bacc, _ := NewBridgeAccounts(nil, config.DataDir, database.NewDBManager(&database.DBConfig{DBType: database.MemoryDB}), DefaultBridgeTxGasLimit, DefaultBridgeTxGasLimit)
	bacc.pAccount.chainID = big.NewInt(0)
	bacc.cAccount.chainID = big.NewInt(0)

	// Generate a new random account and a funded simulator
	aliceKey, _ := crypto.GenerateKey()
	alice := bind.NewKeyedTransactor(aliceKey)
	bobKey, _ := crypto.GenerateKey()
	bob := bind.NewKeyedTransactor(bobKey)

	// Create Simulated backend
	balance := new(big.Int).Mul(big.NewInt(params.KLAY), big.NewInt(100))
	alloc := blockchain.GenesisAlloc{
		alice.From:            {Balance: big.NewInt(params.KLAY)},
		bacc.pAccount.address: {Balance: balance},
		bacc.cAccount.address: {Balance: balance},
	}
	// sim := backends.NewSimulatedBackend(alloc)
	sim := backends.NewSimulatedBackendWithGasPrice(alloc, 26000000000)
	defer sim.Close()

	bc := testBlockChain(t)
	sc := &SubBridge{
		blockchain:     bc,
		txPool:         blockchain.NewTxPool(blockchain.DefaultTxPoolConfig, bc.Config(), bc),
		chainDB:        database.NewDBManager(&database.DBConfig{DBType: database.MemoryDB}),
		config:         config,
		peers:          newBridgePeerSet(),
		bridgeAccounts: bacc,
		// localBackend:   sim,
		// remoteBackend:  sim,
	}
	sc.APIBackend = &SubBridgeAPI{sc}
	sc.handler, err = NewSubBridgeHandler(sc)
	assert.NoError(t, err)

	bm, err := NewBridgeManager(sc)
	assert.NoError(t, err)
	sc.handler.subbridge.bridgeManager = bm

	// 1. Deploy bridge
	pBridgeAddr, err := bm.DeployBridgeTest(sim, 10000, false)
	assert.NoError(t, err)
	cBridgeAddr, err := bm.DeployBridgeTest(sim, 10000, true)
	assert.NoError(t, err)

	pBridgeInfo, ok := bm.GetBridgeInfo(pBridgeAddr)
	assert.Equal(t, ok, true)
	pBridge := pBridgeInfo.bridge
	cBridgeInfo, ok := bm.GetBridgeInfo(cBridgeAddr)
	assert.Equal(t, ok, true)
	cBridge := cBridgeInfo.bridge
	sim.Commit() // block

	pBridgeInfo.counterpartBridge = cBridgeInfo.bridge
	cBridgeInfo.counterpartBridge = pBridgeInfo.bridge

	// 2. Deploy ERC20 Token Contract
	pTokenAddr, tx, pToken, err := sctoken.DeployServiceChainToken(alice, sim, pBridgeAddr)
	assert.NoError(t, err)
	sim.Commit() // block
	cTokenAddr, tx, cToken, err := sctoken.DeployServiceChainToken(alice, sim, cBridgeAddr)
	assert.NoError(t, err)
	sim.Commit() // block

	// 2-1. Give minter role to child bridge contract
	aliceAuth := bind.NewKeyedTransactor(aliceKey)
	tx, err = cToken.AddMinter(aliceAuth, cBridgeAddr)
	sim.Commit() // block
	CheckReceipt(sim, tx, 1*time.Second, types.ReceiptStatusSuccessful, t)
	assert.NoError(t, err)

	// 3. Register the operator account on the child bridge to operator of deployed bridge contract
	pAuth := bacc.pAccount.GenerateTransactOpts()
	_, err = pBridge.RegisterOperator(&bind.TransactOpts{From: pAuth.From, Signer: pAuth.Signer, GasLimit: testGasLimit}, pAuth.From)
	assert.NoError(t, err)

	cAuth := bacc.cAccount.GenerateTransactOpts()
	_, err = cBridge.RegisterOperator(&bind.TransactOpts{From: cAuth.From, Signer: cAuth.Signer, GasLimit: testGasLimit}, cAuth.From)
	assert.NoError(t, err)
	sim.Commit() // block

	// Register tokens on the bridgeInfo
	pBridgeInfo.RegisterToken(pTokenAddr, cTokenAddr)
	cBridgeInfo.RegisterToken(cTokenAddr, pTokenAddr)

	// Register tokens on the bridge
	pBridge.RegisterToken(&bind.TransactOpts{From: pAuth.From, Signer: pAuth.Signer, GasLimit: testGasLimit}, pTokenAddr, cTokenAddr)
	cBridge.RegisterToken(&bind.TransactOpts{From: cAuth.From, Signer: cAuth.Signer, GasLimit: testGasLimit}, cTokenAddr, pTokenAddr)
	// cBridge.RegisterToken(&bind.TransactOpts{From: cAuth.From, Signer: cAuth.Signer, GasLimit: testGasLimit}, cTokenAddr, cTokenAddr)
	sim.Commit() // block

	// 4. Subscribe Bridge Contract
	bm.SubscribeEvent(pBridgeAddr)
	bm.SubscribeEvent(cBridgeAddr)

	reqVTevCh := make(chan RequestValueTransferEvent)
	reqVTencodedEvCh := make(chan RequestValueTransferEncodedEvent)
	handleValueTransferEventCh := make(chan *HandleValueTransferEvent)
	bm.SubscribeReqVTev(reqVTevCh)
	bm.SubscribeReqVTencodedEv(reqVTencodedEvCh)
	bm.SubscribeHandleVTev(handleValueTransferEventCh)

	go func() {
		for {
			select {
			case ev := <-reqVTevCh:
				handleValueTransfer(t, ev, pBridgeInfo, &wg, sim)
			case ev := <-reqVTencodedEvCh:
				handleValueTransfer(t, ev, pBridgeInfo, &wg, sim)
			case ev := <-handleValueTransferEventCh:
				t.Log("Handle value transfer event",
					"bridgeAddr", ev.Raw.Address.Hex(),
					"type", ev.TokenType,
					"amount", ev.ValueOrTokenId,
					"owner", ev.To.String(),
					"contract", ev.Raw.Address.String(),
					"token", ev.TokenAddress.String(),
					"handleNonce", ev.HandleNonce)
				wg.Done()
			}
		}
	}()

	// 1. Request ERC20 Transfer from Alice to Bob
	testToken := big.NewInt(123)
	{
		// Mint first (Note that the parent bridge address has `false` of `modeMintBurn` flag)
		tx, err = pToken.Mint(aliceAuth, pBridgeAddr, testToken)
		assert.NoError(t, err)
		sim.Commit() // block
		CheckReceipt(sim, tx, 1*time.Second, types.ReceiptStatusSuccessful, t)

		fmt.Println(bm.subBridge.blockchain.Config().UnitPrice)
		fmt.Println("1. gasrpice:", bacc.GetParentGasPrice())
		bacc.pAccount.SetGasPrice(big.NewInt(11))
		bacc.cAccount.SetGasPrice(big.NewInt(11))

		fmt.Println("2. gasrpice:", bacc.GetParentGasPrice())
	}

	{
		tx, err = cToken.RequestValueTransfer(&bind.TransactOpts{From: alice.From, Signer: alice.Signer, GasLimit: testGasLimit}, testToken, bob.From, big.NewInt(0), nil)
		assert.NoError(t, err)
		sim.Commit() // block
		CheckReceipt(sim, tx, 1*time.Second, types.ReceiptStatusSuccessful, t)
	}

	WaitGroupWithTimeOut(&wg, 3*time.Second, t)

	// 10. Check Token balance
	{
		balance, err := pToken.BalanceOf(nil, bob.From)
		assert.Equal(t, nil, err)
		assert.Equal(t, testToken.String(), balance.String())
		fmt.Println(testToken.String(), balance.String())
	}

	bm.Stop()
}
